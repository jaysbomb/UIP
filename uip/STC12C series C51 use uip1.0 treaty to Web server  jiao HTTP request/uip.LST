C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE UIP
OBJECT MODULE PLACED IN .\release\uip.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE uip.c LARGE BROWSE DEBUG OBJECTEXTEND OBJECT(.\release\uip.obj)

line level    source

   1          //#define DEBUG_PRINTF(...) /*printf(__VA_ARGS__)*/
   2          
   3          /**
   4           * \defgroup uip The uIP TCP/IP stack
   5           * @{
   6           *
   7           * uIP is an implementation of the TCP/IP protocol stack intended for
   8           * small 8-bit and 16-bit microcontrollers.
   9           *
  10           * uIP provides the necessary protocols for Internet communication,
  11           * with a very small code footprint and RAM requirements - the uIP
  12           * code size is on the order of a few kilobytes and RAM usage is on
  13           * the order of a few hundred bytes.
  14           */
  15          
  16          /**
  17           * \file
  18           * The uIP TCP/IP stack code.
  19           * \author Adam Dunkels <adam@dunkels.com>
  20           */
  21          
  22          /*
  23           * Copyright (c) 2001-2003, Adam Dunkels.
  24           * All rights reserved.
  25           *
  26           * Redistribution and use in source and binary forms, with or without
  27           * modification, are permitted provided that the following conditions
  28           * are met:
  29           * 1. Redistributions of source code must retain the above copyright
  30           *    notice, this list of conditions and the following disclaimer.
  31           * 2. Redistributions in binary form must reproduce the above copyright
  32           *    notice, this list of conditions and the following disclaimer in the
  33           *    documentation and/or other materials provided with the distribution.
  34           * 3. The name of the author may not be used to endorse or promote
  35           *    products derived from this software without specific prior
  36           *    written permission.
  37           *
  38           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  39           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  40           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  41           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  42           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  43           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  44           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  45           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  46           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  47           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  48           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  49           *
  50           * This file is part of the uIP TCP/IP stack.
  51           *
  52           * $Id: uip.c,v 1.65 2006/06/11 21:46:39 adam Exp $
  53           *
  54           */
  55          
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 2   

  56          /*
  57           * uIP is a small implementation of the IP, UDP and TCP protocols (as
  58           * well as some basic ICMP stuff). The implementation couples the IP,
  59           * UDP, TCP and the application layers very tightly. To keep the size
  60           * of the compiled code down, this code frequently uses the goto
  61           * statement. While it would be possible to break the uip_process()
  62           * function into many smaller functions, this would increase the code
  63           * size because of the overhead of parameter passing and the fact that
  64           * the optimier would not be as efficient.
  65           *
  66           * The principle is that we have a small buffer, called the uip_buf,
  67           * in which the device driver puts an incoming packet. The TCP/IP
  68           * stack parses the headers in the packet, and calls the
  69           * application. If the remote host has sent data to the application,
  70           * this data is present in the uip_buf and the application read the
  71           * data from there. It is up to the application to put this data into
  72           * a byte stream if needed. The application will not be fed with data
  73           * that is out of sequence.
  74           *
  75           * If the application whishes to send data to the peer, it should put
  76           * its data into the uip_buf. The uip_appdata pointer points to the
  77           * first available byte. The TCP/IP stack will calculate the
  78           * checksums, and fill in the necessary header fields and finally send
  79           * the packet back to the peer.
  80          */
  81          
  82          #include "uip.h"
  83          #include "uipopt.h"
  84          #include "uip_arch.h"
  85          
  86          #if UIP_CONF_IPV6
              #include "uip-neighbor.h"
              #endif /* UIP_CONF_IPV6 */
  89          
  90          #include <string.h>
  91          
  92          /*---------------------------------------------------------------------------*/
  93          /* Variable definitions. */
  94          
  95          
  96          /* The IP address of this host. If it is defined to be fixed (by
  97             setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
  98             here. Otherwise, the address */
  99          #if UIP_FIXEDADDR > 0
 100          const uip_ipaddr_t uip_hostaddr =
 101            {HTONS((UIP_IPADDR0 << 8) | UIP_IPADDR1),
 102             HTONS((UIP_IPADDR2 << 8) | UIP_IPADDR3)};
 103          const uip_ipaddr_t uip_draddr =
 104            {HTONS((UIP_DRIPADDR0 << 8) | UIP_DRIPADDR1),
 105             HTONS((UIP_DRIPADDR2 << 8) | UIP_DRIPADDR3)};
 106          const uip_ipaddr_t uip_netmask =
 107            {HTONS((UIP_NETMASK0 << 8) | UIP_NETMASK1),
 108             HTONS((UIP_NETMASK2 << 8) | UIP_NETMASK3)};
 109          #else
              uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
              #endif /* UIP_FIXEDADDR */
 112          
 113          static const uip_ipaddr_t all_ones_addr =
 114          #if UIP_CONF_IPV6
                {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
              #else /* UIP_CONF_IPV6 */
 117            {0xffff,0xffff};
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 3   

 118          #endif /* UIP_CONF_IPV6 */
 119          static const uip_ipaddr_t all_zeroes_addr =
 120          #if UIP_CONF_IPV6
                {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000};
              #else /* UIP_CONF_IPV6 */
 123            {0x0000,0x0000};
 124          #endif /* UIP_CONF_IPV6 */
 125          
 126          
 127          #if UIP_FIXEDETHADDR
 128          const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
 129                                                    UIP_ETHADDR1,
 130                                                    UIP_ETHADDR2,
 131                                                    UIP_ETHADDR3,
 132                                                    UIP_ETHADDR4,
 133                                                    UIP_ETHADDR5}};
 134          #else
              struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
              #endif
 137          
 138          #ifndef UIP_CONF_EXTERNAL_BUFFER
 139          u8_t uip_buf[UIP_BUFSIZE + 2];   /* The packet buffer that contains
 140                                              incoming packets. */
 141          #endif /* UIP_CONF_EXTERNAL_BUFFER */
 142          
 143          void *uip_appdata;               /* The uip_appdata pointer points to
 144                                              application data. */
 145          void *uip_sappdata;              /* The uip_appdata pointer points to
 146                                              the application data which is to
 147                                              be sent. */
 148          #if UIP_URGDATA > 0
 149          void *uip_urgdata;               /* The uip_urgdata pointer points to
 150                                              urgent data (out-of-band data), if
 151                                              present. */
 152          u16_t uip_urglen, uip_surglen;
 153          #endif /* UIP_URGDATA > 0 */
 154          
 155          u16_t uip_len, uip_slen;
 156                                       /* The uip_len is either 8 or 16 bits,
 157                                          depending on the maximum packet
 158                                          size. */
 159          
 160          u8_t uip_flags;     /* The uip_flags variable is used for
 161                                          communication between the TCP/IP stack
 162                                          and the application program. */
 163          struct uip_conn *uip_conn;   /* uip_conn always points to the current
 164                                          connection. */
 165          
 166          struct uip_conn uip_conns[UIP_CONNS];
 167                                       /* The uip_conns array holds all TCP
 168                                          connections. */
 169          u16_t uip_listenports[UIP_LISTENPORTS];
 170                                       /* The uip_listenports list all currently
 171                                          listning ports. */
 172          #if UIP_UDP
              struct uip_udp_conn *uip_udp_conn;
              struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
              #endif /* UIP_UDP */
 176          
 177          static u16_t ipid;           /* Ths ipid variable is an increasing
 178                                          number that is used for the IP ID
 179                                          field. */
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 4   

 180          
 181          void uip_setipid(u16_t id) { ipid = id; }
 182          
 183          static u8_t iss[4];          /* The iss variable is used for the TCP
 184                                          initial sequence number. */
 185          
 186          #if UIP_ACTIVE_OPEN
 187          static u16_t lastport;       /* Keeps track of the last port used for
 188                                          a new connection. */
 189          #endif /* UIP_ACTIVE_OPEN */
 190          
 191          /* Temporary variables. */
 192          u8_t uip_acc32[4];
 193          static u8_t c, opt;
 194          static u16_t tmp16;
 195          
 196          /* Structures and definitions. */
 197          #define TCP_FIN 0x01
 198          #define TCP_SYN 0x02
 199          #define TCP_RST 0x04
 200          #define TCP_PSH 0x08
 201          #define TCP_ACK 0x10
 202          #define TCP_URG 0x20
 203          #define TCP_CTL 0x3f
 204          
 205          #define TCP_OPT_END     0   /* End of TCP options list */
 206          #define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
 207          #define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
 208          
 209          #define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
 210          
 211          #define ICMP_ECHO_REPLY 0
 212          #define ICMP_ECHO       8
 213          
 214          #define ICMP6_ECHO_REPLY             129
 215          #define ICMP6_ECHO                   128
 216          #define ICMP6_NEIGHBOR_SOLICITATION  135
 217          #define ICMP6_NEIGHBOR_ADVERTISEMENT 136
 218          
 219          #define ICMP6_FLAG_S (1 << 6)
 220          
 221          #define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
 222          #define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
 223          
 224          
 225          /* Macros. */
 226          #define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
 227          #define FBUF ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
 228          #define ICMPBUF ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
 229          #define UDPBUF ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
 230          
 231          
 232          #if UIP_STATISTICS == 1
 233          struct uip_stats uip_stat;
 234          #define UIP_STAT(s) s
 235          #else
              #define UIP_STAT(s)
              #endif /* UIP_STATISTICS == 1 */
 238          
 239          #if UIP_LOGGING == 1
              #include <stdio.h>
              void uip_log(char *msg);
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 5   

              #define UIP_LOG(m) uip_log(m)
              #else
 244          #define UIP_LOG(m)
 245          #endif /* UIP_LOGGING == 1 */
 246          
 247          #if ! UIP_ARCH_ADD32
 248          void
 249          uip_add32(u8_t *op32, u16_t op16)
 250          {
 251   1        uip_acc32[3] = op32[3] + (op16 & 0xff);
 252   1        uip_acc32[2] = op32[2] + (op16 >> 8);
 253   1        uip_acc32[1] = op32[1];
 254   1        uip_acc32[0] = op32[0];
 255   1        
 256   1        if(uip_acc32[2] < (op16 >> 8)) {
 257   2          ++uip_acc32[1];
 258   2          if(uip_acc32[1] == 0) {
 259   3            ++uip_acc32[0];
 260   3          }
 261   2        }
 262   1        
 263   1        
 264   1        if(uip_acc32[3] < (op16 & 0xff)) {
 265   2          ++uip_acc32[2];
 266   2          if(uip_acc32[2] == 0) {
 267   3            ++uip_acc32[1];
 268   3            if(uip_acc32[1] == 0) {
 269   4              ++uip_acc32[0];
 270   4            }
 271   3          }
 272   2        }
 273   1      }
 274          
 275          #endif /* UIP_ARCH_ADD32 */
 276          
 277          #if ! UIP_ARCH_CHKSUM
 278          /*---------------------------------------------------------------------------*/
 279          static u16_t
 280          chksum(u16_t sum, const u8_t *dat, u16_t len)
 281          {
 282   1        u16_t t;
 283   1        const u8_t *dataptr;
 284   1        const u8_t *last_byte;
 285   1      
 286   1        dataptr = dat;
 287   1        last_byte = dat + len - 1;
 288   1        
 289   1        while(dataptr < last_byte) {  /* At least two more bytes */
 290   2          t = (dataptr[0] << 8) + dataptr[1];
 291   2          sum += t;
 292   2          if(sum < t) {
 293   3            sum++;            /* carry */
 294   3          }
 295   2          dataptr += 2;
 296   2        }
 297   1        
 298   1        if(dataptr == last_byte) {
 299   2          t = (dataptr[0] << 8) + 0;
 300   2          sum += t;
 301   2          if(sum < t) {
 302   3            sum++;            /* carry */
 303   3          }
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 6   

 304   2        }
 305   1      
 306   1        /* Return sum in host byte order. */
 307   1        return sum;
 308   1      }
 309          /*---------------------------------------------------------------------------*/
 310          u16_t
 311          uip_chksum(u16_t *dat, u16_t len)
 312          {
 313   1        return htons(chksum(0, (u8_t *)dat, len));
 314   1      }
 315          /*---------------------------------------------------------------------------*/
 316          #ifndef UIP_ARCH_IPCHKSUM
 317          u16_t
 318          uip_ipchksum(void)
 319          {
 320   1        u16_t sum;
 321   1      
 322   1        sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 323   1        //DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
 324   1        return (sum == 0) ? 0xffff : htons(sum);
 325   1      }
 326          #endif
 327          /*---------------------------------------------------------------------------*/
 328          static u16_t
 329          upper_layer_chksum(u8_t proto)
 330          {
 331   1        u16_t upper_layer_len;
 332   1        u16_t sum;
 333   1        
 334   1      #if UIP_CONF_IPV6
                upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
              #else /* UIP_CONF_IPV6 */
 337   1        upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 338   1      #endif /* UIP_CONF_IPV6 */
 339   1        
 340   1        /* First sum pseudoheader. */
 341   1        
 342   1        /* IP protocol and length fields. This addition cannot carry. */
 343   1        sum = upper_layer_len + proto;
 344   1        /* Sum IP source and destination addresses. */
 345   1        sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
 346   1      
 347   1        /* Sum TCP header and data. */
 348   1        sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
 349   1                     upper_layer_len);
 350   1          
 351   1        return (sum == 0) ? 0xffff : htons(sum);
 352   1      }
 353          /*---------------------------------------------------------------------------*/
 354          #if UIP_CONF_IPV6
              u16_t
              uip_icmp6chksum(void)
              {
                return upper_layer_chksum(UIP_PROTO_ICMP6);
                
              }
              #endif /* UIP_CONF_IPV6 */
 362          /*---------------------------------------------------------------------------*/
 363          u16_t
 364          uip_tcpchksum(void)
 365          {
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 7   

 366   1        return upper_layer_chksum(UIP_PROTO_TCP);
 367   1      }
 368          /*---------------------------------------------------------------------------*/
 369          #if UIP_UDP_CHECKSUMS
              u16_t
              uip_udpchksum(void)
              {
                return upper_layer_chksum(UIP_PROTO_UDP);
              }
              #endif /* UIP_UDP_CHECKSUMS */
 376          #endif /* UIP_ARCH_CHKSUM */
 377          /*---------------------------------------------------------------------------*/
 378          void
 379          uip_init(void)
 380          {
 381   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
 382   2          uip_listenports[c] = 0;
 383   2        }
 384   1        for(c = 0; c < UIP_CONNS; ++c) {
 385   2          uip_conns[c].tcpstateflags = UIP_CLOSED;
 386   2        }
 387   1      #if UIP_ACTIVE_OPEN
 388   1        lastport = 1024;
 389   1      #endif /* UIP_ACTIVE_OPEN */
 390   1      
 391   1      #if UIP_UDP
                for(c = 0; c < UIP_UDP_CONNS; ++c) {
                  uip_udp_conns[c].lport = 0;
                }
              #endif /* UIP_UDP */
 396   1        
 397   1      
 398   1        /* IPv4 initialization. */
 399   1      #if UIP_FIXEDADDR == 0
                /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
              #endif /* UIP_FIXEDADDR */
 402   1      
 403   1      }
 404          /*---------------------------------------------------------------------------*/
 405          #if UIP_ACTIVE_OPEN
 406          struct uip_conn *
 407          uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
 408          {
 409   1        register struct uip_conn *conn, *cconn;
 410   1        
 411   1        /* Find an unused local port. */
 412   1       again:
 413   1        ++lastport;
 414   1      
 415   1        if(lastport >= 32000) {
 416   2          lastport = 4096;
 417   2        }
 418   1      
 419   1        /* Check if this port is already in use, and if so try to find
 420   1           another one. */
 421   1        for(c = 0; c < UIP_CONNS; ++c) {
 422   2          conn = &uip_conns[c];
 423   2          if(conn->tcpstateflags != UIP_CLOSED &&
 424   2             conn->lport == htons(lastport)) {
 425   3            goto again;
 426   3          }
 427   2        }
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 8   

 428   1      
 429   1        conn = 0;
 430   1        for(c = 0; c < UIP_CONNS; ++c) {
 431   2          cconn = &uip_conns[c];
 432   2          if(cconn->tcpstateflags == UIP_CLOSED) {
 433   3            conn = cconn;
 434   3            break;
 435   3          }
 436   2          if(cconn->tcpstateflags == UIP_TIME_WAIT) {
 437   3            if(conn == 0 ||
 438   3               cconn->timer > conn->timer) {
 439   4              conn = cconn;
 440   4            }
 441   3          }
 442   2        }
 443   1      
 444   1        if(conn == 0) {
 445   2          return 0;
 446   2        }
 447   1        
 448   1        conn->tcpstateflags = UIP_SYN_SENT;
 449   1      
 450   1        conn->snd_nxt[0] = iss[0];
 451   1        conn->snd_nxt[1] = iss[1];
 452   1        conn->snd_nxt[2] = iss[2];
 453   1        conn->snd_nxt[3] = iss[3];
 454   1      
 455   1        conn->initialmss = conn->mss = UIP_TCP_MSS;
 456   1        
 457   1        conn->len = 1;   /* TCP length of the SYN is one. */
 458   1        conn->nrtx = 0;
 459   1        conn->timer = 1; /* Send the SYN next time around. */
 460   1        conn->rto = UIP_RTO;
 461   1        conn->sa = 0;
 462   1        conn->sv = 16;   /* Initial value of the RTT variance. */
 463   1        conn->lport = htons(lastport);
 464   1        conn->rport = rport;
 465   1        uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 466   1        
 467   1        return conn;
 468   1      }
 469          #endif /* UIP_ACTIVE_OPEN */
 470          /*---------------------------------------------------------------------------*/
 471          #if UIP_UDP
              struct uip_udp_conn *
              uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
              {
                register struct uip_udp_conn *conn;
                
                /* Find an unused local port. */
               again:
                ++lastport;
              
                if(lastport >= 32000) {
                  lastport = 4096;
                }
                
                for(c = 0; c < UIP_UDP_CONNS; ++c) {
                  if(uip_udp_conns[c].lport == htons(lastport)) {
                    goto again;
                  }
                }
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 9   

              
              
                conn = 0;
                for(c = 0; c < UIP_UDP_CONNS; ++c) {
                  if(uip_udp_conns[c].lport == 0) {
                    conn = &uip_udp_conns[c];
                    break;
                  }
                }
              
                if(conn == 0) {
                  return 0;
                }
                
                conn->lport = HTONS(lastport);
                conn->rport = rport;
                if(ripaddr == NULL) {
                  memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
                } else {
                  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
                }
                conn->ttl = UIP_TTL;
                
                return conn;
              }
              #endif /* UIP_UDP */
 516          /*---------------------------------------------------------------------------*/
 517          void
 518          uip_unlisten(u16_t port)
 519          {
 520   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
 521   2          if(uip_listenports[c] == port) {
 522   3            uip_listenports[c] = 0;
 523   3            return;
 524   3          }
 525   2        }
 526   1      }
 527          /*---------------------------------------------------------------------------*/
 528          void
 529          uip_listen(u16_t port)
 530          {
 531   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
 532   2          if(uip_listenports[c] == 0) {
 533   3            uip_listenports[c] = port;
 534   3            return;
 535   3          }
 536   2        }
 537   1      }
 538          /*---------------------------------------------------------------------------*/
 539          /* XXX: IP fragment reassembly: not well-tested. */
 540          
 541          #if UIP_REASSEMBLY && !UIP_CONF_IPV6
              #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
              static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
              static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
              static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
                                                  0x0f, 0x07, 0x03, 0x01};
              static u16_t uip_reasslen;
              static u8_t uip_reassflags;
              #define UIP_REASS_FLAG_LASTFRAG 0x01
              static u8_t uip_reasstmr;
              
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 10  

              #define IP_MF   0x20
              
              static u8_t
              uip_reass(void)
              {
                u16_t offset, len;
                u16_t i;
              
                /* If ip_reasstmr is zero, no packet is present in the buffer, so we
                   write the IP header of the fragment into the reassembly
                   buffer. The timer is updated with the maximum age. */
                if(uip_reasstmr == 0) {
                  memcpy(uip_reassbuf, &BUF->vhl, UIP_IPH_LEN);
                  uip_reasstmr = UIP_REASS_MAXAGE;
                  uip_reassflags = 0;
                  /* Clear the bitmap. */
                  memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
                }
              
                /* Check if the incoming fragment matches the one currently present
                   in the reasembly buffer. If so, we proceed with copying the
                   fragment into the buffer. */
                if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
                   BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
                   BUF->destipaddr[0] == FBUF->destipaddr[0] &&
                   BUF->destipaddr[1] == FBUF->destipaddr[1] &&
                   BUF->ipid[0] == FBUF->ipid[0] &&
                   BUF->ipid[1] == FBUF->ipid[1]) {
              
                  len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
                  offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;
              
                  /* If the offset or the offset + fragment length overflows the
                     reassembly buffer, we discard the entire packet. */
                  if(offset > UIP_REASS_BUFSIZE ||
                     offset + len > UIP_REASS_BUFSIZE) {
                    uip_reasstmr = 0;
                    goto nullreturn;
                  }
              
                  /* Copy the fragment into the reassembly buffer, at the right
                     offset. */
                  memcpy(&uip_reassbuf[UIP_IPH_LEN + offset],
                         (char *)BUF + (int)((BUF->vhl & 0x0f) * 4),
                         len);
                    
                  /* Update the bitmap. */
                  if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
                    /* If the two endpoints are in the same byte, we only update
                       that byte. */
                           
                    uip_reassbitmap[offset / (8 * 8)] |=
                           bitmap_bits[(offset / 8 ) & 7] &
                           ~bitmap_bits[((offset + len) / 8 ) & 7];
                  } else {
                    /* If the two endpoints are in different bytes, we update the
                       bytes in the endpoints and fill the stuff inbetween with
                       0xff. */
                    uip_reassbitmap[offset / (8 * 8)] |=
                      bitmap_bits[(offset / 8 ) & 7];
                    for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
                      uip_reassbitmap[i] = 0xff;
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 11  

                    }
                    uip_reassbitmap[(offset + len) / (8 * 8)] |=
                      ~bitmap_bits[((offset + len) / 8 ) & 7];
                  }
                  
                  /* If this fragment has the More Fragments flag set to zero, we
                     know that this is the last fragment, so we can calculate the
                     size of the entire packet. We also set the
                     IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
                     the final fragment. */
              
                  if((BUF->ipoffset[0] & IP_MF) == 0) {
                    uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
                    uip_reasslen = offset + len;
                  }
                  
                  /* Finally, we check if we have a full packet in the buffer. We do
                     this by checking if we have the last fragment and if all bits
                     in the bitmap are set. */
                  if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
                    /* Check all bytes up to and including all but the last byte in
                       the bitmap. */
                    for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
                      if(uip_reassbitmap[i] != 0xff) {
                        goto nullreturn;
                      }
                    }
                    /* Check the last byte in the bitmap. It should contain just the
                       right amount of bits. */
                    if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
                       (u8_t)~bitmap_bits[uip_reasslen / 8 & 7]) {
                      goto nullreturn;
                    }
              
                    /* If we have come this far, we have a full packet in the
                       buffer, so we allocate a pbuf and copy the packet into it. We
                       also reset the timer. */
                    uip_reasstmr = 0;
                    memcpy(BUF, FBUF, uip_reasslen);
              
                    /* Pretend to be a "normal" (i.e., not fragmented) IP packet
                       from now on. */
                    BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
                    BUF->len[0] = uip_reasslen >> 8;
                    BUF->len[1] = uip_reasslen & 0xff;
                    BUF->ipchksum = 0;
                    BUF->ipchksum = ~(uip_ipchksum());
              
                    return uip_reasslen;
                  }
                }
              
               nullreturn:
                return 0;
              }
              #endif /* UIP_REASSEMBLY */
 670          /*---------------------------------------------------------------------------*/
 671          static void
 672          uip_add_rcv_nxt(u16_t n)
 673          {
 674   1        uip_add32(uip_conn->rcv_nxt, n);
 675   1        uip_conn->rcv_nxt[0] = uip_acc32[0];
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 12  

 676   1        uip_conn->rcv_nxt[1] = uip_acc32[1];
 677   1        uip_conn->rcv_nxt[2] = uip_acc32[2];
 678   1        uip_conn->rcv_nxt[3] = uip_acc32[3];
 679   1      }
 680          /*---------------------------------------------------------------------------*/
 681          void
 682          uip_process(u8_t flag)
 683          {
 684   1        register struct uip_conn *uip_connr = uip_conn;
 685   1      
 686   1      #if UIP_UDP
                if(flag == UIP_UDP_SEND_CONN) {
                  goto udp_send;
                }
              #endif /* UIP_UDP */
 691   1        
 692   1        uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 693   1      
 694   1        /* Check if we were invoked because of a poll request for a
 695   1           particular connection. */
 696   1        if(flag == UIP_POLL_REQUEST) {
 697   2          if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
 698   2             !uip_outstanding(uip_connr)) {
 699   3              uip_flags = UIP_POLL;
 700   3              UIP_APPCALL();
 701   3              goto appsend;
 702   3          }
 703   2          goto drop;
 704   2          
 705   2          /* Check if we were invoked because of the perodic timer fireing. */
 706   2        } else if(flag == UIP_TIMER) {
 707   2      #if UIP_REASSEMBLY
                  if(uip_reasstmr != 0) {
                    --uip_reasstmr;
                  }
              #endif /* UIP_REASSEMBLY */
 712   2          /* Increase the initial sequence number. */
 713   2          if(++iss[3] == 0) {
 714   3            if(++iss[2] == 0) {
 715   4              if(++iss[1] == 0) {
 716   5                ++iss[0];
 717   5              }
 718   4            }
 719   3          }
 720   2      
 721   2          /* Reset the length variables. */
 722   2          uip_len = 0;
 723   2          uip_slen = 0;
 724   2      
 725   2          /* Check if the connection is in a state in which we simply wait
 726   2             for the connection to time out. If so, we increase the
 727   2             connection's timer and remove the connection if it times
 728   2             out. */
 729   2          if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
 730   2             uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
 731   3            ++(uip_connr->timer);
 732   3            if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 733   4              uip_connr->tcpstateflags = UIP_CLOSED;
 734   4            }
 735   3          } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
 736   3            /* If the connection has outstanding data, we increase the
 737   3               connection's timer and see if it has reached the RTO value
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 13  

 738   3               in which case we retransmit. */
 739   3            if(uip_outstanding(uip_connr)) {
 740   4              if(uip_connr->timer-- == 0) {
 741   5                if(uip_connr->nrtx == UIP_MAXRTX ||
 742   5                   ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
 743   5                     uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
 744   5                    uip_connr->nrtx == UIP_MAXSYNRTX)) {
 745   6                  uip_connr->tcpstateflags = UIP_CLOSED;
 746   6      
 747   6                  /* We call UIP_APPCALL() with uip_flags set to
 748   6                     UIP_TIMEDOUT to inform the application that the
 749   6                     connection has timed out. */
 750   6                  uip_flags = UIP_TIMEDOUT;
 751   6                  UIP_APPCALL();
 752   6      
 753   6                  /* We also send a reset packet to the remote host. */
 754   6                  BUF->flags = TCP_RST | TCP_ACK;
 755   6                  goto tcp_send_nodata;
 756   6                }
 757   5      
 758   5                /* Exponential backoff. */
 759   5                uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 760   5                                               4:
 761   5                                               uip_connr->nrtx);
 762   5                ++(uip_connr->nrtx);
 763   5                
 764   5                /* Ok, so we need to retransmit. We do this differently
 765   5                   depending on which state we are in. In ESTABLISHED, we
 766   5                   call upon the application so that it may prepare the
 767   5                   data for the retransmit. In SYN_RCVD, we resend the
 768   5                   SYNACK that we sent earlier and in LAST_ACK we have to
 769   5                   retransmit our FINACK. */
 770   5                UIP_STAT(++uip_stat.tcp.rexmit);
 771   5                switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
 772   6                case UIP_SYN_RCVD:
 773   6                  /* In the SYN_RCVD state, we should retransmit our
 774   6                     SYNACK. */
 775   6                  goto tcp_send_synack;
 776   6                  
 777   6      #if UIP_ACTIVE_OPEN
 778   6                case UIP_SYN_SENT:
 779   6                  /* In the SYN_SENT state, we retransmit out SYN. */
 780   6                  BUF->flags = 0;
 781   6                  goto tcp_send_syn;
 782   6      #endif /* UIP_ACTIVE_OPEN */
 783   6                  
 784   6                case UIP_ESTABLISHED:
 785   6                  /* In the ESTABLISHED state, we call upon the application
 786   6                     to do the actual retransmit after which we jump into
 787   6                     the code for sending out the packet (the apprexmit
 788   6                     label). */
 789   6                  uip_flags = UIP_REXMIT;
 790   6                  UIP_APPCALL();
 791   6                  goto apprexmit;
 792   6                  
 793   6                case UIP_FIN_WAIT_1:
 794   6                case UIP_CLOSING:
 795   6                case UIP_LAST_ACK:
 796   6                  /* In all these states we should retransmit a FINACK. */
 797   6                  goto tcp_send_finack;
 798   6                  
 799   6                }
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 14  

 800   5              }
 801   4            } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
 802   4              /* If there was no need for a retransmission, we poll the
 803   4                 application for new data. */
 804   4              uip_flags = UIP_POLL;
 805   4              UIP_APPCALL();
 806   4              goto appsend;
 807   4            }
 808   3          }
 809   2          goto drop;
 810   2        }
 811   1      #if UIP_UDP
                if(flag == UIP_UDP_TIMER) {
                  if(uip_udp_conn->lport != 0) {
                    uip_conn = NULL;
                    uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
                    uip_len = uip_slen = 0;
                    uip_flags = UIP_POLL;
                    UIP_UDP_APPCALL();
                    goto udp_send;
                  } else {
                    goto drop;
                  }
                }
              #endif
 825   1      
 826   1        /* This is where the input processing starts. */
 827   1        UIP_STAT(++uip_stat.ip.recv);
 828   1      
 829   1        /* Start of IP input header processing code. */
 830   1        
 831   1      #if UIP_CONF_IPV6
                /* Check validity of the IP header. */
                if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
                  UIP_STAT(++uip_stat.ip.drop);
                  UIP_STAT(++uip_stat.ip.vhlerr);
                  UIP_LOG("ipv6: invalid version.");
                  goto drop;
                }
              #else /* UIP_CONF_IPV6 */
 840   1        /* Check validity of the IP header. */
 841   1        if(BUF->vhl != 0x45)  { /* IP version and header length. */
 842   2          UIP_STAT(++uip_stat.ip.drop);
 843   2          UIP_STAT(++uip_stat.ip.vhlerr);
 844   2          UIP_LOG("ip: invalid version or header length.");
 845   2          goto drop;
 846   2        }
 847   1      #endif /* UIP_CONF_IPV6 */
 848   1        
 849   1        /* Check the size of the packet. If the size reported to us in
 850   1           uip_len is smaller the size reported in the IP header, we assume
 851   1           that the packet has been corrupted in transit. If the size of
 852   1           uip_len is larger than the size reported in the IP packet header,
 853   1           the packet has been padded and we set uip_len to the correct
 854   1           value.. */
 855   1      
 856   1        if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
 857   2          uip_len = (BUF->len[0] << 8) + BUF->len[1];
 858   2      #if UIP_CONF_IPV6
                  uip_len += 40; /* The length reported in the IPv6 header is the
                                    length of the payload that follows the
                                    header. However, uIP uses the uip_len variable
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 15  

                                    for holding the size of the entire packet,
                                    including the IP header. For IPv4 this is not a
                                    problem as the length field in the IPv4 header
                                    contains the length of the entire packet. But
                                    for IPv6 we need to add the size of the IPv6
                                    header (40 bytes). */
              #endif /* UIP_CONF_IPV6 */
 869   2        } else {
 870   2          UIP_LOG("ip: packet shorter than reported in IP header.");
 871   2          goto drop;
 872   2        }
 873   1      
 874   1      #if !UIP_CONF_IPV6
 875   1        /* Check the fragment flag. */
 876   1        if((BUF->ipoffset[0] & 0x3f) != 0 ||
 877   1           BUF->ipoffset[1] != 0) {
 878   2      #if UIP_REASSEMBLY
                  uip_len = uip_reass();
                  if(uip_len == 0) {
                    goto drop;
                  }
              #else /* UIP_REASSEMBLY */
 884   2          UIP_STAT(++uip_stat.ip.drop);
 885   2          UIP_STAT(++uip_stat.ip.fragerr);
 886   2          UIP_LOG("ip: fragment dropped.");
 887   2          goto drop;
 888   2      #endif /* UIP_REASSEMBLY */
 889   2        }
 890   1      #endif /* UIP_CONF_IPV6 */
 891   1      
 892   1        if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
 893   2          /* If we are configured to use ping IP address configuration and
 894   2             hasn't been assigned an IP address yet, we accept all ICMP
 895   2             packets. */
 896   2      #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
                  if(BUF->proto == UIP_PROTO_ICMP) {
                    UIP_LOG("ip: possible ping config packet received.");
                    goto icmp_input;
                  } else {
                    UIP_LOG("ip: packet dropped since no address assigned.");
                    goto drop;
                  }
              #endif /* UIP_PINGADDRCONF */
 905   2      
 906   2        } else {
 907   2          /* If IP broadcast support is configured, we check for a broadcast
 908   2             UDP packet, which may be destined to us. */
 909   2      #if UIP_BROADCAST
                  DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
                  if(BUF->proto == UIP_PROTO_UDP &&
                     uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
                     /*&&
                       uip_ipchksum() == 0xffff*/) {
                    goto udp_input;
                  }
              #endif /* UIP_BROADCAST */
 918   2          
 919   2          /* Check if the packet is destined for our IP address. */
 920   2      #if !UIP_CONF_IPV6
 921   2          if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
 922   3            UIP_STAT(++uip_stat.ip.drop);
 923   3            goto drop;
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 16  

 924   3          }
 925   2      #else /* UIP_CONF_IPV6 */
                  /* For IPv6, packet reception is a little trickier as we need to
                     make sure that we listen to certain multicast addresses (all
                     hosts multicast address, and the solicited-node multicast
                     address) as well. However, we will cheat here and accept all
                     multicast packets that are sent to the ff02::/16 addresses. */
                  if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
                     BUF->destipaddr[0] != HTONS(0xff02)) {
                    UIP_STAT(++uip_stat.ip.drop);
                    goto drop;
                  }
              #endif /* UIP_CONF_IPV6 */
 937   2        }
 938   1      
 939   1      #if !UIP_CONF_IPV6
 940   1        if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
 941   2                                          checksum. */
 942   2          UIP_STAT(++uip_stat.ip.drop);
 943   2          UIP_STAT(++uip_stat.ip.chkerr);
 944   2          UIP_LOG("ip: bad checksum.");
 945   2          goto drop;
 946   2        }
 947   1      #endif /* UIP_CONF_IPV6 */
 948   1      
 949   1        if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
 950   2                                             proceed with TCP input
 951   2                                             processing. */
 952   2          goto tcp_input;
 953   2        }
 954   1      
 955   1      #if UIP_UDP
                if(BUF->proto == UIP_PROTO_UDP) {
                  goto udp_input;
                }
              #endif /* UIP_UDP */
 960   1      
 961   1      #if !UIP_CONF_IPV6
 962   1        /* ICMPv4 processing code follows. */
 963   1        if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
 964   2                                              here. */
 965   2          UIP_STAT(++uip_stat.ip.drop);
 966   2          UIP_STAT(++uip_stat.ip.protoerr);
 967   2          UIP_LOG("ip: neither tcp nor icmp.");
 968   2          goto drop;
 969   2        }
 970   1      
 971   1      #if UIP_PINGADDRCONF
               icmp_input:
              #endif /* UIP_PINGADDRCONF */
 974   1        UIP_STAT(++uip_stat.icmp.recv);
 975   1      
 976   1        /* ICMP echo (i.e., ping) processing. This is simple, we only change
 977   1           the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
 978   1           checksum before we return the packet. */
 979   1        if(ICMPBUF->type != ICMP_ECHO) {
 980   2          UIP_STAT(++uip_stat.icmp.drop);
 981   2          UIP_STAT(++uip_stat.icmp.typeerr);
 982   2          UIP_LOG("icmp: not icmp echo.");
 983   2          goto drop;
 984   2        }
 985   1      
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 17  

 986   1        /* If we are configured to use ping IP address assignment, we use
 987   1           the destination IP address of this ping packet and assign it to
 988   1           ourself. */
 989   1      #if UIP_PINGADDRCONF
                if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
                  uip_hostaddr[0] = BUF->destipaddr[0];
                  uip_hostaddr[1] = BUF->destipaddr[1];
                }
              #endif /* UIP_PINGADDRCONF */
 995   1      
 996   1        ICMPBUF->type = ICMP_ECHO_REPLY;
 997   1      
 998   1        if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
 999   2          ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
1000   2        } else {
1001   2          ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
1002   2        }
1003   1      
1004   1        /* Swap IP addresses. */
1005   1        uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
1006   1        uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1007   1      
1008   1        UIP_STAT(++uip_stat.icmp.sent);
1009   1        goto send;
1010   1      
1011   1        /* End of IPv4 input header processing code. */
1012   1      #else /* !UIP_CONF_IPV6 */
              
                /* This is IPv6 ICMPv6 processing code. */
                DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
              
                if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
                                                       here. */
                  UIP_STAT(++uip_stat.ip.drop);
                  UIP_STAT(++uip_stat.ip.protoerr);
                  UIP_LOG("ip: neither tcp nor icmp6.");
                  goto drop;
                }
              
                UIP_STAT(++uip_stat.icmp.recv);
              
                /* If we get a neighbor solicitation for our address we should send
                   a neighbor advertisement message back. */
                if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
                  if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {
              
                    if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
                      /* Save the sender's address in our neighbor list. */
                      uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
                    }
                    
                    /* We should now send a neighbor advertisement back to where the
                       neighbor solicication came from. */
                    ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
                    ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
                    
                    ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
                    
                    uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
                    uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
                    ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
                    ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 18  

                    memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
                    ICMPBUF->icmpchksum = 0;
                    ICMPBUF->icmpchksum = ~uip_icmp6chksum();
                    goto send;
                    
                  }
                  goto drop;
                } else if(ICMPBUF->type == ICMP6_ECHO) {
                  /* ICMP echo (i.e., ping) processing. This is simple, we only
                     change the ICMP type from ECHO to ECHO_REPLY and update the
                     ICMP checksum before we return the packet. */
              
                  ICMPBUF->type = ICMP6_ECHO_REPLY;
                  
                  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
                  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
                  ICMPBUF->icmpchksum = 0;
                  ICMPBUF->icmpchksum = ~uip_icmp6chksum();
                  
                  UIP_STAT(++uip_stat.icmp.sent);
                  goto send;
                } else {
                  DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
                  UIP_STAT(++uip_stat.icmp.drop);
                  UIP_STAT(++uip_stat.icmp.typeerr);
                  UIP_LOG("icmp: unknown ICMP message.");
                  goto drop;
                }
              
                /* End of IPv6 ICMP processing. */
                
              #endif /* !UIP_CONF_IPV6 */
1080   1      
1081   1      #if UIP_UDP
                /* UDP input processing. */
               udp_input:
                /* UDP processing is really just a hack. We don't do anything to the
                   UDP/IP headers, but let the UDP application do all the hard
                   work. If the application sets uip_slen, it has a packet to
                   send. */
              #if UIP_UDP_CHECKSUMS
                uip_len = uip_len - UIP_IPUDPH_LEN;
                uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
                if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
                  UIP_STAT(++uip_stat.udp.drop);
                  UIP_STAT(++uip_stat.udp.chkerr);
                  UIP_LOG("udp: bad checksum.");
                  goto drop;
                }
              #else /* UIP_UDP_CHECKSUMS */
                uip_len = uip_len - UIP_IPUDPH_LEN;
              #endif /* UIP_UDP_CHECKSUMS */
              
                /* Demultiplex this UDP packet between the UDP "connections". */
                for(uip_udp_conn = &uip_udp_conns[0];
                    uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
                    ++uip_udp_conn) {
                  /* If the local UDP port is non-zero, the connection is considered
                     to be used. If so, the local port number is checked against the
                     destination port number in the received packet. If the two port
                     numbers match, the remote port number is checked if the
                     connection is bound to a remote port. Finally, if the
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 19  

                     connection is bound to a remote IP address, the source IP
                     address of the packet is checked. */
                  if(uip_udp_conn->lport != 0 &&
                     UDPBUF->destport == uip_udp_conn->lport &&
                     (uip_udp_conn->rport == 0 ||
                      UDPBUF->srcport == uip_udp_conn->rport) &&
                     (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
                      uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
                      uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
                    goto udp_found;
                  }
                }
                UIP_LOG("udp: no matching connection found");
                goto drop;
                
               udp_found:
                uip_conn = NULL;
                uip_flags = UIP_NEWDATA;
                uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
                uip_slen = 0;
                UIP_UDP_APPCALL();
               udp_send:
                if(uip_slen == 0) {
                  goto drop;
                }
                uip_len = uip_slen + UIP_IPUDPH_LEN;
              
              #if UIP_CONF_IPV6
                /* For IPv6, the IP length field does not include the IPv6 IP header
                   length. */
                BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
                BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
              #else /* UIP_CONF_IPV6 */
                BUF->len[0] = (uip_len >> 8);
                BUF->len[1] = (uip_len & 0xff);
              #endif /* UIP_CONF_IPV6 */
              
                BUF->ttl = uip_udp_conn->ttl;
                BUF->proto = UIP_PROTO_UDP;
              
                UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
                UDPBUF->udpchksum = 0;
              
                BUF->srcport  = uip_udp_conn->lport;
                BUF->destport = uip_udp_conn->rport;
              
                uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
                uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
                 
                uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
              
              #if UIP_UDP_CHECKSUMS
                /* Calculate UDP checksum. */
                UDPBUF->udpchksum = ~(uip_udpchksum());
                if(UDPBUF->udpchksum == 0) {
                  UDPBUF->udpchksum = 0xffff;
                }
              #endif /* UIP_UDP_CHECKSUMS */
                
                goto ip_send_nolen;
              #endif /* UIP_UDP */
1171   1        
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 20  

1172   1        /* TCP input processing. */
1173   1       tcp_input:
1174   1        UIP_STAT(++uip_stat.tcp.recv);
1175   1      
1176   1        /* Start of TCP input header processing code. */
1177   1        
1178   1        if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
1179   2                                             checksum. */
1180   2          UIP_STAT(++uip_stat.tcp.drop);
1181   2          UIP_STAT(++uip_stat.tcp.chkerr);
1182   2          UIP_LOG("tcp: bad checksum.");
1183   2          goto drop;
1184   2        }
1185   1        
1186   1        
1187   1        /* Demultiplex this segment. */
1188   1        /* First check any active connections. */
1189   1        for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
1190   1            ++uip_connr) {
1191   2          if(uip_connr->tcpstateflags != UIP_CLOSED &&
1192   2             BUF->destport == uip_connr->lport &&
1193   2             BUF->srcport == uip_connr->rport &&
1194   2             uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
1195   3            goto found;
1196   3          }
1197   2        }
1198   1      
1199   1        /* If we didn't find and active connection that expected the packet,
1200   1           either this packet is an old duplicate, or this is a SYN packet
1201   1           destined for a connection in LISTEN. If the SYN flag isn't set,
1202   1           it is an old packet and we send a RST. */
1203   1        if((BUF->flags & TCP_CTL) != TCP_SYN) {
1204   2          goto reset;
1205   2        }
1206   1        
1207   1        tmp16 = BUF->destport;
1208   1        /* Next, check listening connections. */
1209   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
1210   2          if(tmp16 == uip_listenports[c])
1211   2            goto found_listen;
1212   2        }
1213   1        
1214   1        /* No matching connection found, so we send a RST packet. */
1215   1        UIP_STAT(++uip_stat.tcp.synrst);
1216   1       reset:
1217   1      
1218   1        /* We do not send resets in response to resets. */
1219   1        if(BUF->flags & TCP_RST) {
1220   2          goto drop;
1221   2        }
1222   1      
1223   1        UIP_STAT(++uip_stat.tcp.rst);
1224   1        
1225   1        BUF->flags = TCP_RST | TCP_ACK;
1226   1        uip_len = UIP_IPTCPH_LEN;
1227   1        BUF->tcpoffset = 5 << 4;
1228   1      
1229   1        /* Flip the seqno and ackno fields in the TCP header. */
1230   1        c = BUF->seqno[3];
1231   1        BUF->seqno[3] = BUF->ackno[3];
1232   1        BUF->ackno[3] = c;
1233   1        
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 21  

1234   1        c = BUF->seqno[2];
1235   1        BUF->seqno[2] = BUF->ackno[2];
1236   1        BUF->ackno[2] = c;
1237   1        
1238   1        c = BUF->seqno[1];
1239   1        BUF->seqno[1] = BUF->ackno[1];
1240   1        BUF->ackno[1] = c;
1241   1        
1242   1        c = BUF->seqno[0];
1243   1        BUF->seqno[0] = BUF->ackno[0];
1244   1        BUF->ackno[0] = c;
1245   1      
1246   1        /* We also have to increase the sequence number we are
1247   1           acknowledging. If the least significant byte overflowed, we need
1248   1           to propagate the carry to the other bytes as well. */
1249   1        if(++BUF->ackno[3] == 0) {
1250   2          if(++BUF->ackno[2] == 0) {
1251   3            if(++BUF->ackno[1] == 0) {
1252   4              ++BUF->ackno[0];
1253   4            }
1254   3          }
1255   2        }
1256   1       
1257   1        /* Swap port numbers. */
1258   1        tmp16 = BUF->srcport;
1259   1        BUF->srcport = BUF->destport;
1260   1        BUF->destport = tmp16;
1261   1        
1262   1        /* Swap IP addresses. */
1263   1        uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
1264   1        uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1265   1        
1266   1        /* And send out the RST packet! */
1267   1        goto tcp_send_noconn;
1268   1      
1269   1        /* This label will be jumped to if we matched the incoming packet
1270   1           with a connection in LISTEN. In that case, we should create a new
1271   1           connection and send a SYNACK in return. */
1272   1       found_listen:
1273   1        /* First we check if there are any connections avaliable. Unused
1274   1           connections are kept in the same table as used connections, but
1275   1           unused ones have the tcpstate set to CLOSED. Also, connections in
1276   1           TIME_WAIT are kept track of and we'll use the oldest one if no
1277   1           CLOSED connections are found. Thanks to Eddie C. Dost for a very
1278   1           nice algorithm for the TIME_WAIT search. */
1279   1        uip_connr = 0;
1280   1        for(c = 0; c < UIP_CONNS; ++c) {
1281   2          if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
1282   3            uip_connr = &uip_conns[c];
1283   3            break;
1284   3          }
1285   2          if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
1286   3            if(uip_connr == 0 ||
1287   3               uip_conns[c].timer > uip_connr->timer) {
1288   4              uip_connr = &uip_conns[c];
1289   4            }
1290   3          }
1291   2        }
1292   1      
1293   1        if(uip_connr == 0) {
1294   2          /* All connections are used already, we drop packet and hope that
1295   2             the remote end will retransmit the packet at a time when we
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 22  

1296   2             have more spare connections. */
1297   2          UIP_STAT(++uip_stat.tcp.syndrop);
1298   2          UIP_LOG("tcp: found no unused connections.");
1299   2          goto drop;
1300   2        }
1301   1        uip_conn = uip_connr;
1302   1        
1303   1        /* Fill in the necessary fields for the new connection. */
1304   1        uip_connr->rto = uip_connr->timer = UIP_RTO;
1305   1        uip_connr->sa = 0;
1306   1        uip_connr->sv = 4;
1307   1        uip_connr->nrtx = 0;
1308   1        uip_connr->lport = BUF->destport;
1309   1        uip_connr->rport = BUF->srcport;
1310   1        uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
1311   1        uip_connr->tcpstateflags = UIP_SYN_RCVD;
1312   1      
1313   1        uip_connr->snd_nxt[0] = iss[0];
1314   1        uip_connr->snd_nxt[1] = iss[1];
1315   1        uip_connr->snd_nxt[2] = iss[2];
1316   1        uip_connr->snd_nxt[3] = iss[3];
1317   1        uip_connr->len = 1;
1318   1      
1319   1        /* rcv_nxt should be the seqno from the incoming packet + 1. */
1320   1        uip_connr->rcv_nxt[3] = BUF->seqno[3];
1321   1        uip_connr->rcv_nxt[2] = BUF->seqno[2];
1322   1        uip_connr->rcv_nxt[1] = BUF->seqno[1];
1323   1        uip_connr->rcv_nxt[0] = BUF->seqno[0];
1324   1        uip_add_rcv_nxt(1);
1325   1      
1326   1        /* Parse the TCP MSS option, if present. */
1327   1        if((BUF->tcpoffset & 0xf0) > 0x50) {
1328   2          for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1329   3            opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
1330   3            if(opt == TCP_OPT_END) {
1331   4              /* End of options. */
1332   4              break;
1333   4            } else if(opt == TCP_OPT_NOOP) {
1334   4              ++c;
1335   4              /* NOP option. */
1336   4            } else if(opt == TCP_OPT_MSS &&
1337   3                      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
1338   4              /* An MSS option with the right option length. */
1339   4              tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
1340   4                (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
1341   4              uip_connr->initialmss = uip_connr->mss =
1342   4                tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
1343   4              
1344   4              /* And we are done processing options. */
1345   4              break;
1346   4            } else {
1347   4              /* All other options have a length field, so that we easily
1348   4                 can skip past them. */
1349   4              if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
1350   5                /* If the length field is zero, the options are malformed
1351   5                   and we don't process them further. */
1352   5                break;
1353   5              }
1354   4              c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1355   4            }
1356   3          }
1357   2        }
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 23  

1358   1        
1359   1        /* Our response will be a SYNACK. */
1360   1      #if UIP_ACTIVE_OPEN
1361   1       tcp_send_synack:
1362   1        BUF->flags = TCP_ACK;
1363   1        
1364   1       tcp_send_syn:
1365   1        BUF->flags |= TCP_SYN;
1366   1      #else /* UIP_ACTIVE_OPEN */
               tcp_send_synack:
                BUF->flags = TCP_SYN | TCP_ACK;
              #endif /* UIP_ACTIVE_OPEN */
1370   1        
1371   1        /* We send out the TCP Maximum Segment Size option with our
1372   1           SYNACK. */
1373   1        BUF->optdata[0] = TCP_OPT_MSS;
1374   1        BUF->optdata[1] = TCP_OPT_MSS_LEN;
1375   1        BUF->optdata[2] = (UIP_TCP_MSS) / 256;
1376   1        BUF->optdata[3] = (UIP_TCP_MSS) & 255;
1377   1        uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
1378   1        BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
1379   1        goto tcp_send;
1380   1      
1381   1        /* This label will be jumped to if we found an active connection. */
1382   1       found:
1383   1        uip_conn = uip_connr;
1384   1        uip_flags = 0;
1385   1        /* We do a very naive form of TCP reset processing; we just accept
1386   1           any RST and kill our connection. We should in fact check if the
1387   1           sequence number of this reset is wihtin our advertised window
1388   1           before we accept the reset. */
1389   1        if(BUF->flags & TCP_RST) {
1390   2          uip_connr->tcpstateflags = UIP_CLOSED;
1391   2          UIP_LOG("tcp: got reset, aborting connection.");
1392   2          uip_flags = UIP_ABORT;
1393   2          UIP_APPCALL();
1394   2          goto drop;
1395   2        }
1396   1        /* Calculated the length of the data, if the application has sent
1397   1           any data to us. */
1398   1        c = (BUF->tcpoffset >> 4) << 2;
1399   1        /* uip_len will contain the length of the actual TCP data. This is
1400   1           calculated by subtracing the length of the TCP header (in
1401   1           c) and the length of the IP header (20 bytes). */
1402   1        uip_len = uip_len - c - UIP_IPH_LEN;
1403   1      
1404   1        /* First, check if the sequence number of the incoming packet is
1405   1           what we're expecting next. If not, we send out an ACK with the
1406   1           correct numbers in. */
1407   1        if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
1408   1             ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
1409   2          if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
1410   2             (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
1411   2              BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
1412   2              BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
1413   2              BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
1414   3            goto tcp_send_ack;
1415   3          }
1416   2        }
1417   1      
1418   1        /* Next, check if the incoming segment acknowledges any outstanding
1419   1           data. If so, we update the sequence number, reset the length of
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 24  

1420   1           the outstanding data, calculate RTT estimations, and reset the
1421   1           retransmission timer. */
1422   1        if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
1423   2          uip_add32(uip_connr->snd_nxt, uip_connr->len);
1424   2      
1425   2          if(BUF->ackno[0] == uip_acc32[0] &&
1426   2             BUF->ackno[1] == uip_acc32[1] &&
1427   2             BUF->ackno[2] == uip_acc32[2] &&
1428   2             BUF->ackno[3] == uip_acc32[3]) {
1429   3            /* Update sequence number. */
1430   3            uip_connr->snd_nxt[0] = uip_acc32[0];
1431   3            uip_connr->snd_nxt[1] = uip_acc32[1];
1432   3            uip_connr->snd_nxt[2] = uip_acc32[2];
1433   3            uip_connr->snd_nxt[3] = uip_acc32[3];
1434   3              
1435   3      
1436   3            /* Do RTT estimation, unless we have done retransmissions. */
1437   3            if(uip_connr->nrtx == 0) {
1438   4              signed char m;
1439   4              m = uip_connr->rto - uip_connr->timer;
1440   4              /* This is taken directly from VJs original code in his paper */
1441   4              m = m - (uip_connr->sa >> 3);
1442   4              uip_connr->sa += m;
1443   4              if(m < 0) {
1444   5                m = -m;
1445   5              }
1446   4              m = m - (uip_connr->sv >> 2);
1447   4              uip_connr->sv += m;
1448   4              uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
1449   4      
1450   4            }
1451   3            /* Set the acknowledged flag. */
1452   3            uip_flags = UIP_ACKDATA;
1453   3            /* Reset the retransmission timer. */
1454   3            uip_connr->timer = uip_connr->rto;
1455   3      
1456   3            /* Reset length of outstanding data. */
1457   3            uip_connr->len = 0;
1458   3          }
1459   2          
1460   2        }
1461   1      
1462   1        /* Do different things depending on in what state the connection is. */
1463   1        switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
1464   2          /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
1465   2              implemented, since we force the application to close when the
1466   2              peer sends a FIN (hence the application goes directly from
1467   2              ESTABLISHED to LAST_ACK). */
1468   2        case UIP_SYN_RCVD:
1469   2          /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
1470   2             we are waiting for an ACK that acknowledges the data we sent
1471   2             out the last time. Therefore, we want to have the UIP_ACKDATA
1472   2             flag set. If so, we enter the ESTABLISHED state. */
1473   2          if(uip_flags & UIP_ACKDATA) {
1474   3            uip_connr->tcpstateflags = UIP_ESTABLISHED;
1475   3            uip_flags = UIP_CONNECTED;
1476   3            uip_connr->len = 0;
1477   3            if(uip_len > 0) {
1478   4              uip_flags |= UIP_NEWDATA;
1479   4              uip_add_rcv_nxt(uip_len);
1480   4            }
1481   3            uip_slen = 0;
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 25  

1482   3            UIP_APPCALL();
1483   3            goto appsend;
1484   3          }
1485   2          goto drop;
1486   2      #if UIP_ACTIVE_OPEN
1487   2        case UIP_SYN_SENT:
1488   2          /* In SYN_SENT, we wait for a SYNACK that is sent in response to
1489   2             our SYN. The rcv_nxt is set to sequence number in the SYNACK
1490   2             plus one, and we send an ACK. We move into the ESTABLISHED
1491   2             state. */
1492   2          if((uip_flags & UIP_ACKDATA) &&
1493   2             (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
1494   3      
1495   3            /* Parse the TCP MSS option, if present. */
1496   3            if((BUF->tcpoffset & 0xf0) > 0x50) {
1497   4              for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1498   5                opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
1499   5                if(opt == TCP_OPT_END) {
1500   6                  /* End of options. */
1501   6                  break;
1502   6                } else if(opt == TCP_OPT_NOOP) {
1503   6                  ++c;
1504   6                  /* NOP option. */
1505   6                } else if(opt == TCP_OPT_MSS &&
1506   5                          uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
1507   6                  /* An MSS option with the right option length. */
1508   6                  tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
1509   6                    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
1510   6                  uip_connr->initialmss =
1511   6                    uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
1512   6      
1513   6                  /* And we are done processing options. */
1514   6                  break;
1515   6                } else {
1516   6                  /* All other options have a length field, so that we easily
1517   6                     can skip past them. */
1518   6                  if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
1519   7                    /* If the length field is zero, the options are malformed
1520   7                       and we don't process them further. */
1521   7                    break;
1522   7                  }
1523   6                  c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1524   6                }
1525   5              }
1526   4            }
1527   3            uip_connr->tcpstateflags = UIP_ESTABLISHED;
1528   3            uip_connr->rcv_nxt[0] = BUF->seqno[0];
1529   3            uip_connr->rcv_nxt[1] = BUF->seqno[1];
1530   3            uip_connr->rcv_nxt[2] = BUF->seqno[2];
1531   3            uip_connr->rcv_nxt[3] = BUF->seqno[3];
1532   3            uip_add_rcv_nxt(1);
1533   3            uip_flags = UIP_CONNECTED | UIP_NEWDATA;
1534   3            uip_connr->len = 0;
1535   3            uip_len = 0;
1536   3            uip_slen = 0;
1537   3            UIP_APPCALL();
1538   3            goto appsend;
1539   3          }
1540   2          /* Inform the application that the connection failed */
1541   2          uip_flags = UIP_ABORT;
1542   2          UIP_APPCALL();
1543   2          /* The connection is closed after we send the RST */
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 26  

1544   2          uip_conn->tcpstateflags = UIP_CLOSED;
1545   2          goto reset;
1546   2      #endif /* UIP_ACTIVE_OPEN */
1547   2          
1548   2        case UIP_ESTABLISHED:
1549   2          /* In the ESTABLISHED state, we call upon the application to feed
1550   2          data into the uip_buf. If the UIP_ACKDATA flag is set, the
1551   2          application should put new data into the buffer, otherwise we are
1552   2          retransmitting an old segment, and the application should put that
1553   2          data into the buffer.
1554   2      
1555   2          If the incoming packet is a FIN, we should close the connection on
1556   2          this side as well, and we send out a FIN and enter the LAST_ACK
1557   2          state. We require that there is no outstanding data; otherwise the
1558   2          sequence numbers will be screwed up. */
1559   2      
1560   2          if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
1561   3            if(uip_outstanding(uip_connr)) {
1562   4              goto drop;
1563   4            }
1564   3            uip_add_rcv_nxt(1 + uip_len);
1565   3            uip_flags |= UIP_CLOSE;
1566   3            if(uip_len > 0) {
1567   4              uip_flags |= UIP_NEWDATA;
1568   4            }
1569   3            UIP_APPCALL();
1570   3            uip_connr->len = 1;
1571   3            uip_connr->tcpstateflags = UIP_LAST_ACK;
1572   3            uip_connr->nrtx = 0;
1573   3          tcp_send_finack:
1574   3            BUF->flags = TCP_FIN | TCP_ACK;
1575   3            goto tcp_send_nodata;
1576   3          }
1577   2      
1578   2          /* Check the URG flag. If this is set, the segment carries urgent
1579   2             data that we must pass to the application. */
1580   2          if((BUF->flags & TCP_URG) != 0) {
1581   3      #if UIP_URGDATA > 0
1582   3            uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
1583   3            if(uip_urglen > uip_len) {
1584   4              /* There is more urgent data in the next segment to come. */
1585   4              uip_urglen = uip_len;
1586   4            }
1587   3            uip_add_rcv_nxt(uip_urglen);
1588   3            uip_len -= uip_urglen;
1589   3            uip_urgdata = uip_appdata;
1590   3            uip_appdata += uip_urglen;
1591   3          } else {
1592   3            uip_urglen = 0;
1593   3      #else /* UIP_URGDATA > 0 */
                    uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
                    uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
              #endif /* UIP_URGDATA > 0 */
1597   3          }
1598   2      
1599   2          /* If uip_len > 0 we have TCP data in the packet, and we flag this
1600   2             by setting the UIP_NEWDATA flag and update the sequence number
1601   2             we acknowledge. If the application has stopped the dataflow
1602   2             using uip_stop(), we must not accept any data packets from the
1603   2             remote host. */
1604   2          if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
1605   3            uip_flags |= UIP_NEWDATA;
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 27  

1606   3            uip_add_rcv_nxt(uip_len);
1607   3          }
1608   2      
1609   2          /* Check if the available buffer space advertised by the other end
1610   2             is smaller than the initial MSS for this connection. If so, we
1611   2             set the current MSS to the window size to ensure that the
1612   2             application does not send more data than the other end can
1613   2             handle.
1614   2      
1615   2             If the remote host advertises a zero window, we set the MSS to
1616   2             the initial MSS so that the application will send an entire MSS
1617   2             of data. This data will not be acknowledged by the receiver,
1618   2             and the application will retransmit it. This is called the
1619   2             "persistent timer" and uses the retransmission mechanim.
1620   2          */
1621   2          tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
1622   2          if(tmp16 > uip_connr->initialmss ||
1623   2             tmp16 == 0) {
1624   3            tmp16 = uip_connr->initialmss;
1625   3          }
1626   2          uip_connr->mss = tmp16;
1627   2      
1628   2          /* If this packet constitutes an ACK for outstanding data (flagged
1629   2             by the UIP_ACKDATA flag, we should call the application since it
1630   2             might want to send more data. If the incoming packet had data
1631   2             from the peer (as flagged by the UIP_NEWDATA flag), the
1632   2             application must also be notified.
1633   2      
1634   2             When the application is called, the global variable uip_len
1635   2             contains the length of the incoming data. The application can
1636   2             access the incoming data through the global pointer
1637   2             uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
1638   2             bytes into the uip_buf array.
1639   2      
1640   2             If the application wishes to send any data, this data should be
1641   2             put into the uip_appdata and the length of the data should be
1642   2             put into uip_len. If the application don't have any data to
1643   2             send, uip_len must be set to 0. */
1644   2          if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
1645   3            uip_slen = 0;
1646   3            UIP_APPCALL();
1647   3      
1648   3          appsend:
1649   3            
1650   3            if(uip_flags & UIP_ABORT) {
1651   4              uip_slen = 0;
1652   4              uip_connr->tcpstateflags = UIP_CLOSED;
1653   4              BUF->flags = TCP_RST | TCP_ACK;
1654   4              goto tcp_send_nodata;
1655   4            }
1656   3      
1657   3            if(uip_flags & UIP_CLOSE) {
1658   4              uip_slen = 0;
1659   4              uip_connr->len = 1;
1660   4              uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
1661   4              uip_connr->nrtx = 0;
1662   4              BUF->flags = TCP_FIN | TCP_ACK;
1663   4              goto tcp_send_nodata;
1664   4            }
1665   3      
1666   3            /* If uip_slen > 0, the application has data to be sent. */
1667   3            if(uip_slen > 0) {
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 28  

1668   4      
1669   4              /* If the connection has acknowledged data, the contents of
1670   4                 the ->len variable should be discarded. */
1671   4              if((uip_flags & UIP_ACKDATA) != 0) {
1672   5                uip_connr->len = 0;
1673   5              }
1674   4      
1675   4              /* If the ->len variable is non-zero the connection has
1676   4                 already data in transit and cannot send anymore right
1677   4                 now. */
1678   4              if(uip_connr->len == 0) {
1679   5      
1680   5                /* The application cannot send more than what is allowed by
1681   5                   the mss (the minumum of the MSS and the available
1682   5                   window). */
1683   5                if(uip_slen > uip_connr->mss) {
1684   6                  uip_slen = uip_connr->mss;
1685   6                }
1686   5      
1687   5                /* Remember how much data we send out now so that we know
1688   5                   when everything has been acknowledged. */
1689   5                uip_connr->len = uip_slen;
1690   5              } else {
1691   5      
1692   5                /* If the application already had unacknowledged data, we
1693   5                   make sure that the application does not send (i.e.,
1694   5                   retransmit) out more than it previously sent out. */
1695   5                uip_slen = uip_connr->len;
1696   5              }
1697   4            }
1698   3            uip_connr->nrtx = 0;
1699   3          apprexmit:
1700   3            uip_appdata = uip_sappdata;
1701   3            
1702   3            /* If the application has data to be sent, or if the incoming
1703   3               packet had new data in it, we must send out a packet. */
1704   3            if(uip_slen > 0 && uip_connr->len > 0) {
1705   4              /* Add the length of the IP and TCP headers. */
1706   4              uip_len = uip_connr->len + UIP_TCPIP_HLEN;
1707   4              /* We always set the ACK flag in response packets. */
1708   4              BUF->flags = TCP_ACK | TCP_PSH;
1709   4              /* Send the packet. */
1710   4              goto tcp_send_noopts;
1711   4            }
1712   3            /* If there is no data to send, just send out a pure ACK if
1713   3               there is newdata. */
1714   3            if(uip_flags & UIP_NEWDATA) {
1715   4              uip_len = UIP_TCPIP_HLEN;
1716   4              BUF->flags = TCP_ACK;
1717   4              goto tcp_send_noopts;
1718   4            }
1719   3          }
1720   2          goto drop;
1721   2        case UIP_LAST_ACK:
1722   2          /* We can close this connection if the peer has acknowledged our
1723   2             FIN. This is indicated by the UIP_ACKDATA flag. */
1724   2          if(uip_flags & UIP_ACKDATA) {
1725   3            uip_connr->tcpstateflags = UIP_CLOSED;
1726   3            uip_flags = UIP_CLOSE;
1727   3            UIP_APPCALL();
1728   3          }
1729   2          break;
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 29  

1730   2          
1731   2        case UIP_FIN_WAIT_1:
1732   2          /* The application has closed the connection, but the remote host
1733   2             hasn't closed its end yet. Thus we do nothing but wait for a
1734   2             FIN from the other side. */
1735   2          if(uip_len > 0) {
1736   3            uip_add_rcv_nxt(uip_len);
1737   3          }
1738   2          if(BUF->flags & TCP_FIN) {
1739   3            if(uip_flags & UIP_ACKDATA) {
1740   4              uip_connr->tcpstateflags = UIP_TIME_WAIT;
1741   4              uip_connr->timer = 0;
1742   4              uip_connr->len = 0;
1743   4            } else {
1744   4              uip_connr->tcpstateflags = UIP_CLOSING;
1745   4            }
1746   3            uip_add_rcv_nxt(1);
1747   3            uip_flags = UIP_CLOSE;
1748   3            UIP_APPCALL();
1749   3            goto tcp_send_ack;
1750   3          } else if(uip_flags & UIP_ACKDATA) {
1751   3            uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
1752   3            uip_connr->len = 0;
1753   3            goto drop;
1754   3          }
1755   2          if(uip_len > 0) {
1756   3            goto tcp_send_ack;
1757   3          }
1758   2          goto drop;
1759   2            
1760   2        case UIP_FIN_WAIT_2:
1761   2          if(uip_len > 0) {
1762   3            uip_add_rcv_nxt(uip_len);
1763   3          }
1764   2          if(BUF->flags & TCP_FIN) {
1765   3            uip_connr->tcpstateflags = UIP_TIME_WAIT;
1766   3            uip_connr->timer = 0;
1767   3            uip_add_rcv_nxt(1);
1768   3            uip_flags = UIP_CLOSE;
1769   3            UIP_APPCALL();
1770   3            goto tcp_send_ack;
1771   3          }
1772   2          if(uip_len > 0) {
1773   3            goto tcp_send_ack;
1774   3          }
1775   2          goto drop;
1776   2      
1777   2        case UIP_TIME_WAIT:
1778   2          goto tcp_send_ack;
1779   2          
1780   2        case UIP_CLOSING:
1781   2          if(uip_flags & UIP_ACKDATA) {
1782   3            uip_connr->tcpstateflags = UIP_TIME_WAIT;
1783   3            uip_connr->timer = 0;
1784   3          }
1785   2        }
1786   1        goto drop;
1787   1        
1788   1      
1789   1        /* We jump here when we are ready to send the packet, and just want
1790   1           to set the appropriate TCP sequence numbers in the TCP header. */
1791   1       tcp_send_ack:
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 30  

1792   1        BUF->flags = TCP_ACK;
1793   1       tcp_send_nodata:
1794   1        uip_len = UIP_IPTCPH_LEN;
1795   1       tcp_send_noopts:
1796   1        BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
1797   1       tcp_send:
1798   1        /* We're done with the input processing. We are now ready to send a
1799   1           reply. Our job is to fill in all the fields of the TCP and IP
1800   1           headers before calculating the checksum and finally send the
1801   1           packet. */
1802   1        BUF->ackno[0] = uip_connr->rcv_nxt[0];
1803   1        BUF->ackno[1] = uip_connr->rcv_nxt[1];
1804   1        BUF->ackno[2] = uip_connr->rcv_nxt[2];
1805   1        BUF->ackno[3] = uip_connr->rcv_nxt[3];
1806   1        
1807   1        BUF->seqno[0] = uip_connr->snd_nxt[0];
1808   1        BUF->seqno[1] = uip_connr->snd_nxt[1];
1809   1        BUF->seqno[2] = uip_connr->snd_nxt[2];
1810   1        BUF->seqno[3] = uip_connr->snd_nxt[3];
1811   1      
1812   1        BUF->proto = UIP_PROTO_TCP;
1813   1        
1814   1        BUF->srcport  = uip_connr->lport;
1815   1        BUF->destport = uip_connr->rport;
1816   1      
1817   1        uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1818   1        uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
1819   1      
1820   1        if(uip_connr->tcpstateflags & UIP_STOPPED) {
1821   2          /* If the connection has issued uip_stop(), we advertise a zero
1822   2             window so that the remote host will stop sending data. */
1823   2          BUF->wnd[0] = BUF->wnd[1] = 0;
1824   2        } else {
1825   2          BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
1826   2          BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
1827   2        }
1828   1      
1829   1       tcp_send_noconn:
1830   1        BUF->ttl = UIP_TTL;
1831   1      #if UIP_CONF_IPV6
                /* For IPv6, the IP length field does not include the IPv6 IP header
                   length. */
                BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
                BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
              #else /* UIP_CONF_IPV6 */
1837   1        BUF->len[0] = (uip_len >> 8);
1838   1        BUF->len[1] = (uip_len & 0xff);
1839   1      #endif /* UIP_CONF_IPV6 */
1840   1      
1841   1        BUF->urgp[0] = BUF->urgp[1] = 0;
1842   1        
1843   1        /* Calculate TCP checksum. */
1844   1        BUF->tcpchksum = 0;
1845   1        BUF->tcpchksum = ~(uip_tcpchksum());
1846   1        
1847   1       ip_send_nolen:
1848   1      
1849   1      #if UIP_CONF_IPV6
                BUF->vtc = 0x60;
                BUF->tcflow = 0x00;
                BUF->flow = 0x00;
              #else /* UIP_CONF_IPV6 */
C51 COMPILER V8.12   UIP                                                                   04/21/2011 21:03:36 PAGE 31  

1854   1        BUF->vhl = 0x45;
1855   1        BUF->tos = 0;
1856   1        BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
1857   1        ++ipid;
1858   1        BUF->ipid[0] = ipid >> 8;
1859   1        BUF->ipid[1] = ipid & 0xff;
1860   1        /* Calculate IP checksum. */
1861   1        BUF->ipchksum = 0;
1862   1        BUF->ipchksum = ~(uip_ipchksum());
1863   1        //DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
1864   1      #endif /* UIP_CONF_IPV6 */
1865   1         
1866   1        UIP_STAT(++uip_stat.tcp.sent);
1867   1       send:
1868   1        //DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len, (BUF->len[0] << 8) | BUF->len[1]);
1869   1        
1870   1        UIP_STAT(++uip_stat.ip.sent);
1871   1        /* Return and let the caller do the actual transmission. */
1872   1        uip_flags = 0;
1873   1        return;
1874   1       drop:
1875   1        uip_len = 0;
1876   1        uip_flags = 0;
1877   1        return;
1878   1      }
*** WARNING C280 IN LINE 1847 OF UIP.C: 'ip_send_nolen': unreferenced label
1879          /*---------------------------------------------------------------------------*/
1880          u16_t
1881          htons(u16_t val)
1882          {
1883   1        return HTONS(val);
1884   1      }
1885          /*---------------------------------------------------------------------------*/
1886          void
1887          uip_send(const void *dat, int len)
1888          {
1889   1        if(len > 0) {
1890   2          uip_slen = len;
1891   2          if(dat != uip_sappdata) {
1892   3            memcpy(uip_sappdata, (dat), uip_slen);
1893   3          }
1894   2        }
1895   1      }
1896          /** @} */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6420    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    629      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
